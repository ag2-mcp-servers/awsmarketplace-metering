# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T12:41:33+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AllocatedUsageQuantity(RootModel[conint(ge=0, le=2147483647)]):
    root: conint(ge=0, le=2147483647)


class Boolean(RootModel[bool]):
    root: bool


class CustomerAWSAccountId(
    RootModel[constr(pattern=r'^[0-9]+$', min_length=1, max_length=255)]
):
    root: constr(pattern=r'^[0-9]+$', min_length=1, max_length=255)


class CustomerIdentifier(
    RootModel[constr(pattern=r'[\s\S]+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\s\S]+', min_length=1, max_length=255)


class CustomerNotEntitledException(RootModel[Any]):
    root: Any


class DisabledApiException(RootModel[Any]):
    root: Any


class DuplicateRequestException(RootModel[Any]):
    root: Any


class ExpiredTokenException(RootModel[Any]):
    root: Any


class InternalServiceErrorException(RootModel[Any]):
    root: Any


class InvalidCustomerIdentifierException(RootModel[Any]):
    root: Any


class InvalidEndpointRegionException(RootModel[Any]):
    root: Any


class InvalidProductCodeException(RootModel[Any]):
    root: Any


class InvalidPublicKeyVersionException(RootModel[Any]):
    root: Any


class InvalidRegionException(RootModel[Any]):
    root: Any


class InvalidTagException(RootModel[Any]):
    root: Any


class InvalidTokenException(RootModel[Any]):
    root: Any


class InvalidUsageAllocationsException(RootModel[Any]):
    root: Any


class InvalidUsageDimensionException(RootModel[Any]):
    root: Any


class NonEmptyString(RootModel[constr(pattern=r'[\s\S]+')]):
    root: constr(pattern=r'[\s\S]+')


class Nonce(RootModel[constr(pattern=r'[\s\S]*', max_length=255)]):
    root: constr(pattern=r'[\s\S]*', max_length=255)


class PlatformNotSupportedException(RootModel[Any]):
    root: Any


class ProductCode(
    RootModel[constr(pattern=r'^[-a-zA-Z0-9/=:_.@]*$', min_length=1, max_length=255)]
):
    root: constr(pattern=r'^[-a-zA-Z0-9/=:_.@]*$', min_length=1, max_length=255)


class ResolveCustomerRequest(BaseModel):
    RegistrationToken: NonEmptyString


class ResolveCustomerResult(BaseModel):
    CustomerAWSAccountId_1: Optional[CustomerAWSAccountId] = Field(
        None, alias='CustomerAWSAccountId'
    )
    CustomerIdentifier_1: Optional[CustomerIdentifier] = Field(
        None, alias='CustomerIdentifier'
    )
    ProductCode_1: Optional[ProductCode] = Field(None, alias='ProductCode')


class String(RootModel[str]):
    root: str


class TagKey(
    RootModel[constr(pattern=r'^[a-zA-Z0-9+ -=._:\/@]+$', min_length=1, max_length=100)]
):
    root: constr(pattern=r'^[a-zA-Z0-9+ -=._:\/@]+$', min_length=1, max_length=100)


class TagValue(
    RootModel[constr(pattern=r'^[a-zA-Z0-9+ -=._:\/@]+$', min_length=1, max_length=256)]
):
    root: constr(pattern=r'^[a-zA-Z0-9+ -=._:\/@]+$', min_length=1, max_length=256)


class ThrottlingException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class TimestampOutOfBoundsException(RootModel[Any]):
    root: Any


class UsageDimension(
    RootModel[constr(pattern=r'[\s\S]+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[\s\S]+', min_length=1, max_length=255)


class UsageQuantity(RootModel[conint(ge=0, le=2147483647)]):
    root: conint(ge=0, le=2147483647)


class UsageRecordResultStatus(Enum):
    Success = 'Success'
    CustomerNotSubscribed = 'CustomerNotSubscribed'
    DuplicateRecord = 'DuplicateRecord'


class VersionInteger(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class XAmzTarget(Enum):
    AWSMPMeteringService_BatchMeterUsage = 'AWSMPMeteringService.BatchMeterUsage'


class XAmzTarget1(Enum):
    AWSMPMeteringService_MeterUsage = 'AWSMPMeteringService.MeterUsage'


class XAmzTarget2(Enum):
    AWSMPMeteringService_RegisterUsage = 'AWSMPMeteringService.RegisterUsage'


class XAmzTarget3(Enum):
    AWSMPMeteringService_ResolveCustomer = 'AWSMPMeteringService.ResolveCustomer'


class MeterUsageResult(BaseModel):
    MeteringRecordId: Optional[String] = None


class RegisterUsageRequest(BaseModel):
    Nonce_1: Optional[Nonce] = Field(None, alias='Nonce')
    ProductCode_1: ProductCode = Field(..., alias='ProductCode')
    PublicKeyVersion: VersionInteger


class RegisterUsageResult(BaseModel):
    PublicKeyRotationTimestamp: Optional[Timestamp] = None
    Signature: Optional[NonEmptyString] = None


class Tag(BaseModel):
    Key: TagKey
    Value: TagValue


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=5, min_length=1)


class UsageAllocation(BaseModel):
    AllocatedUsageQuantity_1: AllocatedUsageQuantity = Field(
        ..., alias='AllocatedUsageQuantity'
    )
    Tags: Optional[TagList] = None


class UsageAllocations(RootModel[List[UsageAllocation]]):
    root: List[UsageAllocation] = Field(..., max_length=2500, min_length=1)


class UsageRecord(BaseModel):
    CustomerIdentifier_1: CustomerIdentifier = Field(..., alias='CustomerIdentifier')
    Dimension: UsageDimension
    Quantity: Optional[UsageQuantity] = None
    Timestamp_1: Timestamp = Field(..., alias='Timestamp')
    UsageAllocations_1: Optional[UsageAllocations] = Field(
        None, alias='UsageAllocations'
    )


class UsageRecordList(RootModel[List[UsageRecord]]):
    root: List[UsageRecord] = Field(..., max_length=25, min_length=0)


class UsageRecordResult(BaseModel):
    MeteringRecordId: Optional[String] = None
    Status: Optional[UsageRecordResultStatus] = None
    UsageRecord_1: Optional[UsageRecord] = Field(None, alias='UsageRecord')


class UsageRecordResultList(RootModel[List[UsageRecordResult]]):
    root: List[UsageRecordResult]


class BatchMeterUsageRequest(BaseModel):
    ProductCode_1: ProductCode = Field(..., alias='ProductCode')
    UsageRecords: UsageRecordList


class BatchMeterUsageResult(BaseModel):
    Results: Optional[UsageRecordResultList] = None
    UnprocessedRecords: Optional[UsageRecordList] = None


class MeterUsageRequest(BaseModel):
    DryRun: Optional[Boolean] = None
    ProductCode_1: ProductCode = Field(..., alias='ProductCode')
    Timestamp_1: Timestamp = Field(..., alias='Timestamp')
    UsageAllocations_1: Optional[UsageAllocations] = Field(
        None, alias='UsageAllocations'
    )
    UsageDimension_1: UsageDimension = Field(..., alias='UsageDimension')
    UsageQuantity_1: Optional[UsageQuantity] = Field(None, alias='UsageQuantity')
